#include "../include/private/named_pipe.h"
#include <filesystem>

std::vector<std::string> parseMessage(const std::string& message, char delimiter) {
    std::vector<std::string> tokens;
    std::stringstream ss(message);
    std::string token;

    while (std::getline(ss, token, delimiter)) {
        tokens.push_back(token);
    }

    return tokens;
}

void ScanFolder(const fs::path& directory, ScanEngine& scanEngine, std::string& response) {
    for (const auto& entry : fs::directory_iterator(directory)) {
        if (entry.is_directory()) {
            ScanFolder(entry.path(), scanEngine, response);
        }
        else if (entry.is_regular_file()) {
            std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t> convert;
            FileStream file(convert.from_bytes(entry.path().string()));
            std::shared_ptr<IOStream> stream = std::make_shared<FileStream>(file);
            std::string malwareName;

            logger << (LogMsg() << entry.path());

            bool scanResult = scanEngine.ScanFile(stream, malwareName);
            
            std::ostringstream oss;
            oss << entry.path().string() << "|"
                << (scanResult ? "true" : "false") << "|"
                << (scanResult ? malwareName : "none");

            if (!response.empty()) {
                response += "&";
            }
            response += oss.str();
        }
    }
}

VOID readPipeCommandAndProceesIt(PipeServer pipe_server)
{
    try
    {
        AccountManager::HTTPManager manager;
        LicenseManager::HTTPManager licenseManager;
        av_bases_lib::AvBasesUpdater avManager;
        avManager.GetDBAndManifest();
        std::u16string signatureFilePath = u"C:/Projects/Antimalware/AntimalwareService/AvBasesData.bin";
        std::u16string oldSignatureFilePath = u"C:/Projects/Antimalware/AntimalwareService/AvBasesDataOld.bin";

        AvBasesStore basesStore = AvBasesStore();
        auto bases = basesStore.Load(signatureFilePath);

        if (bases == nullptr && std::filesystem::exists(std::filesystem::path(oldSignatureFilePath)))
        {
            avManager.RepairBasesFile();
        }

        ScanEngine scanEngine(bases);        

        logger << "Pipe Client connected successfully";

        bool running = true;

        while (running)
        {
            std::string received_message = pipe_server.PipeRead();

            if (received_message.empty())
            {
                DWORD err = GetLastError();
                if (err == ERROR_BROKEN_PIPE)
                {
                    logger << "Pipe connection broken";
                    running = false;
                }
                continue;
            }

            received_message.erase(received_message.find_last_not_of(" \n\r") + 1);
            logger << (LogMsg() << "Received message: " << received_message);

            std::vector<std::string> parsed_tokens = parseMessage(received_message, '|');
            std::string response = "Error";

            if (!parsed_tokens.empty())
            {
                std::string first_token = parsed_tokens[0];
                logger << (LogMsg() << "First token: " << first_token);

                if (first_token == "Register")
                {
                    logger << "Register command received";

                    response = manager.Register(
                        parsed_tokens[1],
                        parsed_tokens[2],
                        parsed_tokens[3]
                    );
                }
                else if (first_token == "Login")
                {
                    logger << "Login command received";

                    response = manager.Login(
                        parsed_tokens[1],
                        parsed_tokens[2],
                        std::stoi(parsed_tokens[3])
                    );
                }
                else if (first_token == "AllLicense")
                {
                    logger << "AllLicense command received";

                    response = licenseManager.GetAllLicenses(
                        parsed_tokens[1],
                        parsed_tokens[2],
                        manager.GetAccessToken()
                    );
                }
                else if (first_token == "LicenseInfo")
                {
                    logger << "LicenseInfo command received";

                    response = licenseManager.GetLicenseInfo(
                        parsed_tokens[1],
                        parsed_tokens[2],
                        parsed_tokens[3],
                        manager.GetAccessToken()
                    );
                }
                else if (first_token == "AllRenewal")
                {
                    logger << (LogMsg() << "AllRenewal command received.");

                    response = licenseManager.GetAllRenewal(manager.GetAccessToken());
                }
                else if (first_token == "RenewalLicense")
                {
                    logger << (LogMsg() << "AllRenewal command received.");

                    response = licenseManager.RenewalLicense(
                        parsed_tokens[1],
                        manager.GetAccessToken()
                    );
                }
                else if (first_token == "ActivateLicense")
                {
                    logger << "ActivateLicense command received.";

                    response = licenseManager.ActivateLicense(
                        parsed_tokens[1],
                        parsed_tokens[2],
                        parsed_tokens[3],
                        manager.GetAccessToken()
                    );
                }
                else if (first_token == "RefreshToken")
                {
                    logger << (LogMsg() << "RefreshToken command received.");

                    manager.RefreshToken();

                    response = "";
                }
                else if (first_token == "RefreshTicket")
                {
                    logger << (LogMsg() << "RefreshTicket command received.");

                    response = licenseManager.RefreshTicket(manager.GetAccessToken());
                }
                else if (first_token == "RefreshBases")
                {
                    logger << (LogMsg() << "RefreshBases command received.");

                    avManager.GetDBAndManifest();

                    bases = basesStore.Load(signatureFilePath);

                    if (bases == nullptr && std::filesystem::exists(oldSignatureFilePath))
                    {
                        avManager.RepairBasesFile();
                    }
                
                    scanEngine.SetBases(bases);

                    response = "";
                }
                else if (first_token == "LicenseDeactivate")
                {
                    logger << (LogMsg() << "LicenseDeactivate command received.");

                    licenseManager.DeactivateLicense();

                    logger << (LogMsg() << "License cleared.");

                    response = "";
                }
                else if (first_token == "ScanFile")
                {
                    logger << "ScanFile command received.";

                    std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t> convert;
                    FileStream file(convert.from_bytes(parsed_tokens[1]));
                    std::shared_ptr<IOStream> stream = std::make_shared<FileStream>(file);
                    std::string malwareName;
                    bool scanResult = scanEngine.ScanFile(stream, malwareName);
                    std::string scanResultStr = scanResult ? "true" : "false";

                    response = parsed_tokens[1] + "|" + scanResultStr + "|" + malwareName;
                    logger << (LogMsg() << response);
                }
                else if (first_token == "ScanFolder") {
                    logger << (LogMsg() << "ScanFolder command received.");

                    response = "";

                    ScanFolder(parsed_tokens[1], scanEngine, response);
                }
                else if (first_token == "LogOut")
                {
                    logger << (LogMsg() << "Log Out command received.");

                    manager.LogOut();

                    response = "";
                }
                else if (first_token == "Exit")
                {
                    logger << (LogMsg() << "Exit command received.");
                    running = false;
                }
                else
                {
                    std::cout << "Unknown command: " << first_token << std::endl;
                }
                
            }

            if (response != "")
            {
                logger << (LogMsg() << response);
                pipe_server.PipeWrite(response + '\n');
            }

            Sleep(300);
        }

    }
    catch (const std::exception& e)
    {
        logger << e.what();
    }
}

VOID SvcRunNamedPipe(SECURITY_ATTRIBUTES sa)
{
    PipeServer pipe_server(sa);
    pipe_server.WaitClientConnection();

    readPipeCommandAndProceesIt(pipe_server);
}
