#include "../include/private/antimalware_service.h"
#include "../include/private/win_service.h"

typedef std::basic_string<TCHAR> Tstring;
VOID SvcInit(DWORD, LPTSTR *);
VOID WINAPI SvcMain(DWORD, LPTSTR *);
VOID SvcRunNamedPipe(SECURITY_ATTRIBUTES sa);

std::jthread pipeThread;

// Точка входа в приложение
int __cdecl _tmain(int argc, TCHAR *argv[])
{
    // Добавление поддержки русского языка в консоли
    setlocale(LC_ALL, "ru");

    if (lstrcmpi(argv[1], TEXT("/install")) == 0)
    {
        logger << "Запуск установки службы ...";

        SvcInstall();
        return 0;
    }
    else if (lstrcmpi(argv[1], TEXT("/start")) == 0)
    {
        logger << "Запуск службы ...";

        DoStartSvc();
        return 0;
    }
    else if (lstrcmpi(argv[1], TEXT("/stop")) == 0)
    {
        logger << "Запуск остановки службы ...";

        DoStopSvc();
        return 0;
    }
    else if (lstrcmpi(argv[1], TEXT("/uninstall")) == 0)
    {
        logger << "Запуск деинсталляции службы ...";

        DoDeleteSvc();
        return 0;
    }
    else
    {
        // Описание точки входа для SCM
        SERVICE_TABLE_ENTRY DispatchTable[] =
            {
                {WITHOUT_CONST(SVCNAME), (LPSERVICE_MAIN_FUNCTION)SvcMain},
                {NULL, NULL}};

        logger << "Запуск StartServiceCtrlDispatcher...";
        if (!StartServiceCtrlDispatcher(DispatchTable))
        {
            DWORD lastError = GetLastError();

            switch (lastError)
            {
            case ERROR_FAILED_SERVICE_CONTROLLER_CONNECT:
            {
                logger << "ERROR_FAILED_SERVICE_CONTROLLER_CONNECT";
                break;
            }
            case ERROR_INVALID_DATA:
            {
                logger << "ERROR_INVALID_DATA";
                break;
            }
            case ERROR_SERVICE_ALREADY_RUNNING:
            {
                logger << "ERROR_SERVICE_ALREADY_RUNNING";
                break;
            }
            }
        }
    }

    return 0;
}

HANDLE GetUserToken(DWORD sessionId) {
    HANDLE userToken = nullptr;

    if (WTSQueryUserToken(sessionId, &userToken)) {
        logger << "Токен пользователя успешно получен";
    }
    else {
        logger << (LogMsg() << "Не получилось получить токен пользователя (" << GetLastError() << ")");
    }

    return userToken;
}

SECURITY_ATTRIBUTES GetSecurityAttributes(const Tstring& sddl) {

    SECURITY_ATTRIBUTES securityAttributes{};
    securityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
    securityAttributes.bInheritHandle = TRUE;

    PSECURITY_DESCRIPTOR psd = nullptr;

    if (ConvertStringSecurityDescriptorToSecurityDescriptor(sddl.c_str(), SDDL_REVISION_1, &psd, nullptr)) {
        securityAttributes.lpSecurityDescriptor = psd;
    }
    else {
        logger << (LogMsg() << "Неудалось распарсить SECURITY DESCRIPTOR (" << GetLastError() << ")");
    }

    return securityAttributes;
}

Tstring GetUserID(HANDLE userToken) {

    Tstring userSid;
    DWORD err = 0;
    LPVOID pvInfo = NULL;
    DWORD cbSize = 0;
    if (!GetTokenInformation(userToken, TokenUser, NULL, 0, &cbSize))
    {
        err = GetLastError();
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            err = 0;
            pvInfo = LocalAlloc(LPTR, cbSize);

            if (!pvInfo)
            {
                err = ERROR_OUTOFMEMORY;
            }
            else if (!GetTokenInformation(userToken, TokenUser, pvInfo, cbSize, &cbSize)) {
                err = GetLastError();
            }
            else
            {
                err = 0;
                const TOKEN_USER* pUser = (const TOKEN_USER*)pvInfo;
                LPTSTR userSidBuf;
                ConvertSidToStringSid(pUser->User.Sid, &userSidBuf);
                userSid.assign(userSidBuf);
                LocalFree(userSidBuf);
            }
        }
    }

    return userSid;
}

/* Точка входа в службу */
VOID WINAPI SvcMain(DWORD dwArgc, LPTSTR *lpszArgv)
{
    // Регистрация обработчика управляющих сообщений для службы
    gSvcStatusHandle = RegisterServiceCtrlHandler(
        SVCNAME,         // Имя службы
        SvcCtrlHandler); // Обработчик

    if (!gSvcStatusHandle)
    {
        logger << (LogMsg() << "Не получилось зарегистрировать обработчик для службы (" << GetLastError() << ")");
        return;
    }

    // Определяем значение в структуре статуса службы
    gSvcStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS; // Тип службы
    gSvcStatus.dwServiceSpecificExitCode = 0;             // ExitCode

    logger << "Служба будет находится в состоянии SERVICE_START_PENDING в течении 3 секунд";
    ReportSvcStatus(SERVICE_START_PENDING, NO_ERROR, 3000);

    logger << "Запуск функции SvcInit";
    SvcInit(dwArgc, lpszArgv);
}

/* Функция, в которой описана основная работа службы */
VOID SvcInit(DWORD dwArgc, LPTSTR *lpszArgv)
{
    logger << (LogMsg() << "(SvcInit) Thread ID: " << std::this_thread::get_id() << " " << GetCurrentProcessId());

    // Создание события, которое будет сигнализировать об остановке службы
    ghSvcStopEvent = CreateEvent(
        NULL,  // Аттрибуты события
        TRUE,  // Ручной сброс события
        FALSE, // Не сигнализировать сразу после создания события
        NULL); // Имя события

    if (ghSvcStopEvent == NULL)
    {
        DWORD lastError = GetLastError();

        logger << (LogMsg() << "CreateEvent вернул NULL (" << lastError << ")");

        // Отправка в SCM состояния об остановке службы
        ReportSvcStatus(SERVICE_STOPPED, GetLastError(), 0);
        return;
    }

    // Отправка статуса SCM о работе службы
    ReportSvcStatus(SERVICE_RUNNING, NO_ERROR, 0);
    
    logger << "Работа службы";

    DWORD sessionId = WTSGetActiveConsoleSessionId();

    HANDLE userToken = GetUserToken(sessionId);

    // SvcUIInit(userToken);

    Tstring pipeSddl = std::format(__TEXT("O:SYG:SYD:(A;OICI;GA;;;{})"), GetUserID(userToken));

    SECURITY_ATTRIBUTES sa = GetSecurityAttributes(pipeSddl);

    pipeThread = std::jthread(SvcRunNamedPipe, sa);

    if (pipeThread.joinable())
    {
        pipeThread.join();
    }

    logger << "Завершение работы службы";
    // Отправка статуса SCM о завершении службы
    ReportSvcStatus(SERVICE_STOPPED, NO_ERROR, 0);
}