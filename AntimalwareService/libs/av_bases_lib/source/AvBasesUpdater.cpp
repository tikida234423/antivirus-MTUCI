#include "../include/public/AvBasesUpdater.h"
#include "../../../os_services_lib/include/public/stream_receiver.h"
#include "../../../account_manager_lib/include/public/account_manager.h"
#include <curl/curl.h>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <string>

using namespace av_bases_lib;

AvBasesUpdater::AvBasesUpdater()
{

}

size_t WriteCallbackData(void* contents, size_t size, size_t nmemb, void* userp) {
    size_t totalSize = size * nmemb;
    std::ofstream* outFile = static_cast<std::ofstream*>(userp);

    if (outFile->is_open()) {
        outFile->write(static_cast<char*>(contents), totalSize);
    }

    return totalSize;
}

void AvBasesUpdater::LogResponse(std::string response)
{
    logger << (LogMsg() << "Response: " << response);
}

bool AvBasesUpdater::sendHttpRequest(const std::string url, std::string filePath) 
{
    CURL* curl;
    CURLcode res;
    long response_code = 0;
    double total_time = 0;
    char* content_type = nullptr;

    // Log request start
    logger << (LogMsg() << "[HTTP REQUEST] Starting request to: " << url);
    logger << (LogMsg() << "[HTTP REQUEST] Output file: " << filePath);

    curl = curl_easy_init();
    if (curl) {
        std::ofstream outFile(filePath, std::ios::binary);
        if (!outFile.is_open()) {
            logger << (LogMsg() << "[HTTP ERROR] Failed to open file for writing: " << filePath);
            std::cerr << "Failed to open file for writing!" << std::endl;
            curl_easy_cleanup(curl);
            return false;
        }

        // Enable verbose logging for debugging
        curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);
        
        // Set the URL
        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        
        // Set the write callback function
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallbackData);
        
        // Pass the user object (file) to the callback function
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, static_cast<void*>(&outFile));
        
        // SSL options
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
        
        // Set user agent
        curl_easy_setopt(curl, CURLOPT_USERAGENT, "AntimalwareService/1.0");
        
        // Set timeout
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L);
        curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 10L);

        // Log request details
        logger << (LogMsg() << "[HTTP REQUEST] User-Agent: AntimalwareService/1.0");
        logger << (LogMsg() << "[HTTP REQUEST] Timeout: 30s, Connect timeout: 10s");
        logger << (LogMsg() << "[HTTP REQUEST] SSL verification disabled");

        // Perform the request
        logger << (LogMsg() << "[HTTP REQUEST] Executing request...");
        res = curl_easy_perform(curl);
        
        // Get response information
        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response_code);
        curl_easy_getinfo(curl, CURLINFO_TOTAL_TIME, &total_time);
        curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &content_type);
        
        // Log response details
        logger << (LogMsg() << "[HTTP RESPONSE] Status code: " << response_code);
        logger << (LogMsg() << "[HTTP RESPONSE] Total time: " << total_time << "s");
        if (content_type) {
            logger << (LogMsg() << "[HTTP RESPONSE] Content-Type: " << content_type);
        }
        
        if (res != CURLE_OK) {
            logger << (LogMsg() << "[HTTP ERROR] CURL error code: " << res);
            logger << (LogMsg() << "[HTTP ERROR] CURL error message: " << curl_easy_strerror(res));
            std::cerr << "CURL error: " << curl_easy_strerror(res) << std::endl;
            
            // Cleanup cURL session
            curl_easy_cleanup(curl);
            outFile.close();
            return false;
        }
        
        // Check HTTP status code
        if (response_code >= 400) {
            logger << (LogMsg() << "[HTTP ERROR] HTTP error status: " << response_code);
        } else {
            logger << (LogMsg() << "[HTTP SUCCESS] Request completed successfully");
        }

        // Cleanup cURL session
        curl_easy_cleanup(curl);

        // Close the file
        outFile.close();
        
        // Log file size if successful
        if (std::filesystem::exists(filePath)) {
            auto file_size = std::filesystem::file_size(filePath);
            logger << (LogMsg() << "[HTTP RESPONSE] Downloaded file size: " << file_size << " bytes");
        }
    }
    else {
        logger << (LogMsg() << "[HTTP ERROR] Failed to initialize cURL!");
        std::cerr << "Failed to initialize cURL!" << std::endl;
        return false;
    }

    logger << (LogMsg() << "[HTTP COMPLETE] Data successfully written to file: " << filePath);
    std::cout << "Data successfully written to file " << filePath << std::endl;
    return true;
}

void AvBasesUpdater::GetDBAndManifest()
{

    std::string licenseUrl = baseURL + "/signature/data";

    if (std::filesystem::exists(filePath))
    {
        std::filesystem::rename(filePath, oldFilePath);
    }

    AvBasesUpdater::sendHttpRequest(licenseUrl, filePath);

    std::string manifestUrl = baseURL + "/signature/manifest";

    std::string manifestPath = "C:/Projects/Antimalware/AntimalwareService/manifest.bin";

    AvBasesUpdater::sendHttpRequest(manifestUrl, manifestPath);
}

void AvBasesUpdater::RepairBasesFile()
{
    std::filesystem::rename(oldFilePath, filePath);
}