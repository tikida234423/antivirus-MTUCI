#include "../include/public/AvBases.h"
#include "../include/public/AvBasesStore.h"
#include "../../os_services_lib/include/public/stream_receiver.h"
#include "../../os_services_lib/include/public/file_stream.h"

AvBasesStore::AvBasesStore()
{
	
}

std::shared_ptr<AvBases> AvBasesStore::Load(std::u16string path)
{
	std::multimap<uint64_t, Record>m_records;
	auto file = std::make_shared<FileStream>(path);
	StreamReceiver streamReceiver(std::static_pointer_cast<IOStream>(file));
	uint64_t count;
	if (!streamReceiver.ReadUInt64(count))
	{
		logger << "error count";
		return nullptr;
	}
	logger << "count success";
	for (int i = 0; i < count; i++)
	{
		Record record;
		if (!streamReceiver.ReadGUID(record.id))
		{
			logger << "error guid";
			return nullptr;
		}
		logger << "guid success";
		if (!streamReceiver.ReadString(record.name))
		{
			logger << "error name";
			return nullptr;
		}
		logger << "name success";
		if (!streamReceiver.ReadUInt64(record.signaturePrefix))
		{
			logger << "error prefix";
			return nullptr;
		}
		logger << "prefix success";
		record.signatureHash.resize(32);
		if (!streamReceiver.ReadBlob(record.signatureHash))
		{
			logger << "error hash";
			return nullptr;
		}
		logger << "hash success";
		if (!streamReceiver.ReadUInt32(record.signatureLength))
		{
			logger << "error len";
			return nullptr;
		}
		logger << "len success";
		if (!streamReceiver.ReadObjectType(record.type))
		{
			logger << "error type";
			return nullptr;
		}
		logger << "type success";
		if (!streamReceiver.ReadUInt64(record.offsetStart))
		{
			logger << "error offsetStart";
			return nullptr;
		}
		logger << "offStart success";
		if (!streamReceiver.ReadUInt64(record.offsetEnd))
		{
			logger << "error offsetEnd";
			return nullptr;
		}
		logger << "offEnd success";

		m_records.insert(std::make_pair(record.signaturePrefix, record));
	}
	logger << "bases succesfully read!";
	return std::make_shared<AvBases>(m_records);
}

bool AvBasesStore::Save(const std::shared_ptr<AvBases>& avBases)
{
    std::multimap<uint64_t, Record> m_records = avBases->GetRecords();
	std::u16string baseFileName = u"AvBasesData.bin";
    auto file = std::make_shared<FileStream>(baseFileName);
    StreamReceiver streamReceiver(std::static_pointer_cast<IOStream>(file));

    uint64_t count = m_records.size();
    if (!streamReceiver.WriteUInt64(count))
    {
        logger << "error writing count";
        return false;
    }

    for (const auto& entry : m_records)
    {
        const Record& record = entry.second;

        if (!streamReceiver.WriteGUID(record.id))
        {
            logger << "error writing guid";
            return false;
        }
        logger << "guid succeeded";

        if (!streamReceiver.WriteString(record.name))
        {
            logger << "error writing name";
            return false;
        }
        logger << "name succeeded";

        if (!streamReceiver.WriteUInt64(record.signaturePrefix))
        {
            logger << "error writing prefix";
            return false;
        }
        logger << "prefix succeeded";

        if (!streamReceiver.WriteBlob(record.signatureHash))
        {
            logger << "error writing hash";
            return false;
        }
        logger << "hash succeeded";

        if (!streamReceiver.WriteUInt32(record.signatureLength))
        {
            logger << "error writing length";
            return false;
        }
        logger << "length succeeded";

        if (!streamReceiver.WriteObjectType(record.type))
        {
            logger << "error writing type";
            return false;
        }
        logger << "type succeeded";

        if (!streamReceiver.WriteUInt64(record.offsetStart))
        {
            logger << "error writing offsetStart";
            return false;
        }
        logger << "offsetStart succeeded";

        if (!streamReceiver.WriteUInt64(record.offsetEnd))
        {
            logger << "error writing offsetEnd";
            return false;
        }
        logger << "offsetEnd succeeded";
    }

    logger << "bases successfully written!";
    return true;
}
