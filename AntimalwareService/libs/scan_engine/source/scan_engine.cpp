#include "../include/public/scan_engine.h"
#include "../../os_services_lib/include/public/stream_receiver.h"
#include "../../logger/include/public/Logger.h"

ScanEngine::ScanEngine(const std::shared_ptr<AvBases>& bases)
	: bases(bases)
{ 
}
bool ScanEngine::ScanFile(const std::shared_ptr<IOStream> stream, std::string& threatName)
{
    try
    {
        if (!stream)
        {
            logger << "stream error";
            return false;
        }

        StreamReceiver streamReceiver(stream);
        uint64_t fileSize = stream->GetSize();
        uint64_t position = 0;

        while (position < fileSize)
        {
            uint64_t signaturePrefix;
            stream->SetCurrentPosition(position, PositionSet::Begin);
            if (!streamReceiver.ReadUInt64(signaturePrefix))
            {
                logger << "prefix error";
                return false;
            }
            auto records = bases->FindRecord(signaturePrefix);
            for (const auto& record : records)
            {
                if (position >= record.offsetStart && position <= record.offsetEnd)
                {
                    stream->SetCurrentPosition(position + 8, PositionSet::Begin);
                    std::vector<uint8_t> data(record.signatureLength);
                    if (!streamReceiver.ReadBlob(data))
                    {
                        logger << "data read error";
                        return false;
                    }

                    auto hash = GetHash(data.data(), data.size());
                    std::string hashString = ToHexString(hash);
                    logger << "Computed hash: " << hashString;

                    std::string recordHashString = ToHexString(record.signatureHash);
                    logger << "Record hash: " << recordHashString;

                    if (hash == record.signatureHash)
                    {
                        threatName = record.name;
                        return true;
                    }
                }
            }

            position += 1;
        }

        return false;
    }
    catch(const std::exception& e)
    {
        logger << (LogMsg() << "Exception occurred: " << e.what());
    }
    catch (...)
    {
        logger << "UEBOK";
    }
}



std::vector<uint8_t> ScanEngine::GetHash(const uint8_t* data, const size_t data_size)
{
	HCRYPTPROV hProv = NULL;
	if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))
	{
		return {};
	}
	BOOL hash = FALSE;
	HCRYPTPROV hHash = NULL;
	hash = CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash);
	if (!hash) {
		CryptReleaseContext(hProv, 0);
		return {};
	}
	if (!CryptHashData(hHash, static_cast<const BYTE*>(data), data_size, 0)) {
		CryptDestroyHash(hHash);
		CryptReleaseContext(hProv, 0);
		return {};
	}
	DWORD cbHashSize = 0, dwCount = sizeof(DWORD);
	if (!CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE*)&cbHashSize, &dwCount, 0))
	{
		CryptDestroyHash(hHash);
		CryptReleaseContext(hProv, 0);
		return {};
	}
	std::vector<uint8_t> buffer(cbHashSize);
	if (!CryptGetHashParam(hHash, HP_HASHVAL, reinterpret_cast<BYTE*>(&buffer[0]), &cbHashSize, 0))
	{
		CryptDestroyHash(hHash);
		CryptReleaseContext(hProv, 0);
		return {};
	}
	CryptDestroyHash(hHash);
	CryptReleaseContext(hProv, 0);
	return buffer;
}

std::string ScanEngine::ToHexString(const std::vector<uint8_t>& data) {
    std::ostringstream oss;
    for (const auto& byte : data) {
        oss << std::setw(2) << std::setfill('0') << std::hex << static_cast<int>(byte);
    }
    return oss.str();
}

void ScanEngine::SetBases(const std::shared_ptr<AvBases>& newBases) {
    bases = newBases;
}
