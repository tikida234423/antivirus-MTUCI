#include "../include/public/stream_receiver.h"
#include "../../../libs/logger/include/public/Logger.h"
StreamReceiver::StreamReceiver(const std::shared_ptr<IOStream>& stream)
	:m_stream(stream)
{
}

bool StreamReceiver::ReadUInt8(uint8_t& data)
{
	return m_stream->Read(&data, sizeof(data));
}

bool StreamReceiver::ReadUInt16(uint16_t& data)
{
	return m_stream->Read(reinterpret_cast<uint8_t*>(&data), sizeof(data));
}

bool StreamReceiver::ReadUInt32(uint32_t& data)
{
	return m_stream->Read(reinterpret_cast<uint8_t*>(&data), sizeof(data));
}

bool StreamReceiver::ReadUInt64(uint64_t& data)
{
	return m_stream->Read(reinterpret_cast<uint8_t*>(&data), sizeof(data));
}

bool StreamReceiver::ReadInt8(uint8_t& data)
{
	return m_stream->Read(&data, sizeof(data));
}

bool StreamReceiver::ReadInt16(int16_t& data)
{
	return m_stream->Read(reinterpret_cast<uint8_t*>(&data), sizeof(data));
}

bool StreamReceiver::ReadInt32(int32_t& data)
{
	return m_stream->Read(reinterpret_cast<uint8_t*>(&data), sizeof(data));
}

bool StreamReceiver::ReadInt64(int64_t& data)
{
	return m_stream->Read(reinterpret_cast<uint8_t*>(&data), sizeof(data));
}

bool StreamReceiver::ReadFloat32(float& data)
{
	return m_stream->Read(reinterpret_cast<uint8_t*>(&data), sizeof(data));
}

bool StreamReceiver::ReadFloat64(double& data)
{
	return m_stream->Read(reinterpret_cast<uint8_t*>(&data), sizeof(data));
}

bool StreamReceiver::ReadChar(char& data)
{
	return m_stream->Read(reinterpret_cast<uint8_t*>(&data), sizeof(data));
}

bool StreamReceiver::ReadBool(bool& data)
{
	return m_stream->Read(reinterpret_cast<uint8_t*>(&data), sizeof(data));
}

bool StreamReceiver::ReadString(std::string& data)
{
	uint64_t size = 0;
	if (ReadUInt64(size))
	{
		data.resize(size);
		return m_stream->Read(reinterpret_cast<uint8_t*>(data.data()), size);

	}
	return m_stream->Read(reinterpret_cast<uint8_t*>(&data), sizeof(data));
}

bool StreamReceiver::ReadBlob(std::vector<uint8_t>& data)
{
	uint32_t bytesRead = m_stream->Read(reinterpret_cast<uint8_t*>(data.data()), data.size());
	if (bytesRead > 0)
	{
		if (bytesRead != data.size())
		{
			data.resize(bytesRead);
		}
		data.resize(bytesRead);
		return true;
	}
	return false;
}

bool StreamReceiver::ReadGUID(GUID& guid)
{
	uint64_t part1 = 0;
	uint64_t part2 = 0;

	if (!ReadUInt64(part1)) {
		return false;
	}

	if (!ReadUInt64(part2)) {
		return false;
	}

	std::memcpy(&guid.Data1, &part1, sizeof(uint32_t));
	std::memcpy(reinterpret_cast<uint8_t*>(&guid.Data1) + sizeof(uint32_t), reinterpret_cast<uint8_t*>(&part1) + sizeof(uint32_t), sizeof(uint32_t));
	std::memcpy(reinterpret_cast<uint8_t*>(&guid.Data2) + sizeof(uint16_t), reinterpret_cast<uint8_t*>(&part1) + sizeof(uint64_t) - sizeof(uint16_t), sizeof(uint16_t));
	std::memcpy(guid.Data4, &part2, sizeof(guid.Data4));

	return true;
}

bool StreamReceiver::ReadObjectType(ObjectType& type) {
	std::string typeName;
	if (ReadString(typeName)) {
		type = StringToObjectType(typeName);
		return true;
	}
	return false;
}

bool StreamReceiver::WriteUInt8(uint8_t data)
{
	return sizeof(data) == m_stream->Write(&data, sizeof(data));
}

bool StreamReceiver::WriteUInt16(uint16_t data)
{
	return m_stream->Write(reinterpret_cast<uint8_t*>(&data), sizeof(data));
}

bool StreamReceiver::WriteUInt32(uint32_t data)
{
	return sizeof(data) == m_stream->Write(reinterpret_cast<uint8_t*>(&data), sizeof(data));
}

bool StreamReceiver::WriteUInt64(uint64_t data)
{
	return sizeof(data) == m_stream->Write(reinterpret_cast<uint8_t*>(&data), sizeof(data));
}
bool StreamReceiver::WriteInt8(uint8_t data)
{
	return sizeof(data) == m_stream->Write(&data, sizeof(data));
}

bool StreamReceiver::WriteInt16(int16_t data)
{
	return sizeof(data) == m_stream->Write(reinterpret_cast<uint8_t*>(&data), sizeof(data));
}

bool StreamReceiver::WriteInt32(int32_t data)
{
	return sizeof(data) == m_stream->Write(reinterpret_cast<uint8_t*>(&data), sizeof(data));
}

bool StreamReceiver::WriteInt64(int64_t data)
{
	return sizeof(data) == m_stream->Write(reinterpret_cast<uint8_t*>(&data), sizeof(data));
}

bool StreamReceiver::WriteFloat32(float data)
{
	return sizeof(data) == m_stream->Write(reinterpret_cast<uint8_t*>(&data), sizeof(data));
}

bool StreamReceiver::WriteFloat64(double data)
{
	return sizeof(data) == m_stream->Write(reinterpret_cast<uint8_t*>(&data), sizeof(data));
}

bool StreamReceiver::WriteChar(char data)
{
	return sizeof(data) == m_stream->Write(reinterpret_cast<uint8_t*>(&data), sizeof(data));
}

bool StreamReceiver::WriteBool(bool data)
{
	return sizeof(data) == m_stream->Write(reinterpret_cast<uint8_t*>(&data), sizeof(data));
}

bool StreamReceiver::WriteString(const std::string& data)
{
	if (WriteUInt64(data.size()))
	{
		return sizeof(data) == m_stream->Write(reinterpret_cast<uint8_t*>(const_cast<char*>(data.c_str())), data.size());
	}
	return false;
}

bool StreamReceiver::WriteBlob(const std::vector<uint8_t>& data)
{
	uint64_t size = data.size();
	return size == m_stream->Write(reinterpret_cast<uint8_t*>(const_cast<uint8_t*>(data.data())), size);
}

bool StreamReceiver::WriteGUID(const GUID& guid)
{
	uint64_t part1 = 0;
	uint64_t part2 = 0;

	std::memcpy(&part1, &guid.Data1, sizeof(uint32_t));
	std::memcpy(reinterpret_cast<uint8_t*>(&part1) + sizeof(uint32_t), &guid.Data2, sizeof(uint32_t));
	std::memcpy(reinterpret_cast<uint8_t*>(&part1) + sizeof(uint32_t) + sizeof(uint32_t) - sizeof(uint16_t), &guid.Data3, sizeof(uint16_t));
	std::memcpy(&part2, guid.Data4, sizeof(guid.Data4));

	if (!WriteUInt64(part1) || !WriteUInt64(part2)) {
		return false;
	}

	return true; 
}

bool StreamReceiver::WriteObjectType(ObjectType type) {
	std::string typeName = ObjectTypeToString(type);
	return WriteString(typeName);
}

ObjectType StreamReceiver::StringToObjectType(const std::string& str) {
	if (str == "PE") {
		return ObjectType::PE;
	}
	else if (str == "PythonScript") {
		return ObjectType::PythonScript;
	}

	//logger << "Неизвестный тип объекта: " << str;
	return ObjectType::Undefined;
}


std::string StreamReceiver::ObjectTypeToString(ObjectType type) {
	switch (type) {
	case ObjectType::PE: return "PE";
	case ObjectType::PythonScript: return "PythonScript";
	default: return "Undefined";
	}
}