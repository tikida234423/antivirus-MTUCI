#include "../include/public/pipe_server.h"

PipeServer::PipeServer(SECURITY_ATTRIBUTES sa)
{
    //Create Named Pipe
    hPipe = CreateNamedPipe(TEXT("\\\\.\\pipe\\antivirus"),
        PIPE_ACCESS_DUPLEX,
        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
        PIPE_UNLIMITED_INSTANCES,
        1024,
        1024,
        NMPWAIT_USE_DEFAULT_WAIT,
        0);
}


void PipeServer::WaitClientConnection() 
{
    std::cout << "PipeServer.Waiting for client connection..." << std::endl;
    ConnectNamedPipe(hPipe, NULL);
}

std::string PipeServer::PipeRead()
{
    char buffer[1024 * 8] = { 0 };
    DWORD dwRead;
    DWORD bytesAvailable;

    if (PeekNamedPipe(hPipe, buffer, sizeof(buffer), NULL, &bytesAvailable, NULL))
    {
        if (bytesAvailable > 0) 
        {
            BOOL success = ReadFile(hPipe, buffer, sizeof(buffer) - 1, &dwRead, NULL);

            if (!success || dwRead == 0) {
                std::cout << "Pipe closed/error." << std::endl;
                WaitClientConnection();
                success = ReadFile(hPipe, buffer, sizeof(buffer) - 1, &dwRead, NULL);
            }

            return std::string(buffer, dwRead);
        }
    }
    return "";
}

void PipeServer::PipeWrite(std::string message)
{
    char buffer[1024 * 8] = { 0 };
    strcpy(buffer, message.c_str());
    DWORD dwWritten = 0;
    // logger << (LogMsg() << strlen(buffer));
    if (hPipe0 != INVALID_HANDLE_VALUE)
    {
        WriteFile(hPipe, buffer, strlen(buffer), &dwWritten, NULL);
    }

    // logger << (LogMsg() << dwWritten);
}

PipeServer::~PipeServer()
{
    DisconnectNamedPipe(hPipe);
    CloseHandle(hPipe);
}